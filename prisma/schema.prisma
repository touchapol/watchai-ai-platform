generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String   @id @default(cuid())
  email         String   @unique
  username      String   @unique
  password      String
  role          Role     @default(USER)
  termsAccepted Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  files         File[]
  folders       Folder[]
  conversations Conversation[]

  @@map("users")
}

enum Role {
  USER
  ADMIN
}

model Folder {
  id        String   @id @default(uuid())
  userId    String
  name      String
  parentId  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent    Folder?  @relation("FolderHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children  Folder[] @relation("FolderHierarchy")
  files     File[]

  @@index([userId])
  @@index([parentId])
  @@map("folders")
}

model File {
  id          String   @id @default(uuid())
  userId      String
  folderId    String?
  filename    String
  storagePath String
  mimeType    String
  size        Int
  type        FileType
  isIndexed   Boolean  @default(false)
  indexedAt   DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  folder      Folder?  @relation(fields: [folderId], references: [id], onDelete: SetNull)
  chunks      DocumentChunk[]

  @@index([userId])
  @@index([folderId])
  @@index([isIndexed])
  @@map("files")
}

enum FileType {
  DOCUMENT
  IMAGE
}

// LLM Conversations (Messages are stored in MongoDB)
model Conversation {
  id        String    @id @default(uuid())
  userId    String
  title     String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("conversations")
}

model SystemSettings {
  id        String   @id @default("system")
  sessionTimeoutHours Int @default(168)
  defaultModelId String?
  
  enableLongTermMemory    Boolean @default(true)
  enableUserProfileMemory Boolean @default(true)
  enableRAG               Boolean @default(false)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("system_settings")
}

model AiProvider {
  id          String   @id @default(uuid())
  name        String   @unique
  displayName String
  icon        String   @default("smart_toy")
  color       String   @default("#666666")
  docsUrl     String?
  isActive    Boolean  @default(true)
  priority    Int      @default(0)
  
  apiKeys     ApiKey[]
  models      AiModel[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("ai_providers")
}

model AiModel {
  id          String   @id @default(uuid())
  providerId  String
  name        String
  displayName String
  description String?
  isActive    Boolean  @default(true)
  
  provider    AiProvider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([providerId, name])
  @@index([providerId])
  @@map("ai_models")
}

model ApiKey {
  id          String   @id @default(uuid())
  providerId  String?
  name        String
  description String?
  provider    String   @default("gemini")
  apiKey      String
  isActive    Boolean  @default(true)
  priority    Int      @default(0)
  
  dailyLimit     Int?
  dailyUsed      Int      @default(0)
  minuteLimit    Int?
  minuteUsed     Int      @default(0)
  
  dailyTokenLimit   Int?
  dailyTokenUsed    Int      @default(0)
  minuteTokenLimit  Int?
  minuteTokenUsed   Int      @default(0)
  
  lastResetAt    DateTime @default(now())
  lastMinuteResetAt DateTime @default(now())
  lastUsedAt     DateTime?
  
  isRateLimited  Boolean  @default(false)
  rateLimitedAt  DateTime?
  
  aiProvider  AiProvider? @relation(fields: [providerId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([providerId])
  @@map("api_keys")
}

model DocumentChunk {
  id         String   @id @default(uuid())
  fileId     String?
  kbDocId    String?
  chunkIndex Int
  content    String
  embedding  Unsupported("vector(768)")
  createdAt  DateTime @default(now())

  file       File?            @relation(fields: [fileId], references: [id], onDelete: Cascade)
  kbDoc      KnowledgeBaseDoc? @relation(fields: [kbDocId], references: [id], onDelete: Cascade)

  @@index([fileId])
  @@index([kbDocId])
  @@map("document_chunks")
}

model KnowledgeBaseDoc {
  id          String    @id @default(uuid())
  filename    String
  storagePath String
  mimeType    String
  size        Int
  isIndexed   Boolean   @default(false)
  indexedAt   DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  chunks      DocumentChunk[]

  @@map("knowledge_base_docs")
}
